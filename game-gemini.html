<!DOCTYPE html>
<html>
<head>
<title>Tetris</title>
<style>
body {
    font-family: Arial, sans-serif;
    background-color: #222;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
}

.container {
    display: flex;
    gap: 20px;
}

#tetris {
    border: 2px solid #fff;
}

#score {
    font-size: 2em;
    text-align: center;
}

#next-piece-container {
    border: 1px solid #fff;
    width: 100px;
    height: 80px;
}

#nextPieceCanvas {
  display: block;
}
</style>
</head>
<body>

<div class="container">
    <canvas id="tetris" width="320" height="640"></canvas>
    <div>
        <div id="score">Score: 0</div>
        <div id="next-piece-container">
            <canvas id="nextPieceCanvas" width="100" height="80"></canvas>
        </div>
    </div>
</div>


<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const nextPieceCanvas = document.getElementById('nextPieceCanvas');
const nextPieceCtx = nextPieceCanvas.getContext('2d');
const scoreDisplay = document.getElementById('score');

// Размеры сетки
const ROWS = 20;
const COLUMNS = 10;
const BLOCK_SIZE = 32; // Размер одного блока в пикселях

// Цвета блоков
const COLORS = [
    null, // Пустота
    'cyan',     // I
    'blue',     // J
    'orange',   // L
    'yellow',   // O
    'green',    // S
    'purple',   // T
    'red'       // Z
];

// Фигуры Тетриса (форма, формат: [row, col] относительно центра фигуры)
const SHAPES = [
    [[0, 0], [0, 1], [0, -1], [0, 2]], // I
    [[0, 0], [0, -1], [0, 1], [-1, 1]], // J
    [[0, 0], [0, -1], [0, 1], [-1, -1]], // L
    [[0, 0], [0, 1], [1, 0], [1, 1]],   // O
    [[0, 0], [0, 1], [-1, 0], [-1, -1]], // S
    [[0, 0], [0, -1], [0, 1], [-1, 0]],  // T
    [[0, 0], [0, -1], [0, 1], [1, 0]],   // Z
];

// Функция для создания случайной фигуры
function getRandomShape() {
    const shapeIndex = Math.floor(Math.random() * SHAPES.length);
    return {
        shape: SHAPES[shapeIndex],
        color: COLORS[shapeIndex + 1],
        x: Math.floor(COLUMNS / 2) - 1, // Начальная координата x
        y: 0,                           // Начальная координата y
        rotation: 0,                    // Начальный угол поворота
    };
}

// Инициализация игрового поля
let grid = [];
for (let r = 0; r < ROWS; r++) {
    grid[r] = new Array(COLUMNS).fill(0);
}

let currentPiece = getRandomShape(); // Текущая фигура
let nextPiece = getRandomShape();
let score = 0;
let gameRunning = true;
let dropInterval = 1000; // Интервал падения фигуры (мс)
let lastTime = 0;

function drawBlock(x, y, color, ctx, blockSize) {
    ctx.fillStyle = color;
    ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
    ctx.strokeStyle = '#000';
    ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
}

function drawPiece(piece, ctx, blockSize) {
  for (const block of piece.shape) {
    const rotatedBlock = rotateBlock(block, piece.rotation);
    const x = piece.x + rotatedBlock[1];
    const y = piece.y + rotatedBlock[0];
    if (x >= 0 && x < COLUMNS && y >= 0) {
       drawBlock(x, y, piece.color, ctx, blockSize);
    }
  }
}


function rotateBlock(block, rotation) {
    if (rotation % 4 === 0) {
        return block;
    } else if (rotation % 4 === 1) {
        return [block[1], -block[0]];
    } else if (rotation % 4 === 2) {
        return [-block[0], -block[1]];
    } else if (rotation % 4 === 3) {
        return [-block[1], block[0]];
    }
    return block; // Shouldn't reach here, but for safety
}


function drawGrid() {
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLUMNS; c++) {
            if (grid[r][c] !== 0) {
                drawBlock(c, r, COLORS[grid[r][c]], ctx, BLOCK_SIZE);
            }
        }
    }
}

function drawNextPiece() {
    nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
    const offsetX = 1; // Центрируем по горизонтали
    const offsetY = 1; // Центрируем по вертикали
    const blockSize = 20;

    for (const block of nextPiece.shape) {
        const rotatedBlock = rotateBlock(block, nextPiece.rotation);

        const x = offsetX + rotatedBlock[1];
        const y = offsetY + rotatedBlock[0];

        drawBlock(x, y, nextPiece.color, nextPieceCtx, blockSize);
    }
}


function checkCollision(piece, offsetX = 0, offsetY = 0, rotation = 0) {
    for (const block of piece.shape) {
        const rotatedBlock = rotateBlock(block, (piece.rotation + rotation) % 4);
        const x = piece.x + rotatedBlock[1] + offsetX;
        const y = piece.y + rotatedBlock[0] + offsetY;

        if (x < 0 || x >= COLUMNS || y >= ROWS) { // Стены и пол
            return true;
        }
        if (y < 0) continue;
        if (grid[y][x] !== 0) {
            return true; // Столкновение с существующим блоком
        }
    }
    return false;
}

function placePiece() {
    for (const block of currentPiece.shape) {
        const rotatedBlock = rotateBlock(block, currentPiece.rotation);
        const x = currentPiece.x + rotatedBlock[1];
        const y = currentPiece.y + rotatedBlock[0];
        if (y >= 0) { // Игнорируем блоки, которые выше видимой области
            grid[y][x] = COLORS.indexOf(currentPiece.color);
        }
    }
    clearLines();
    currentPiece = nextPiece;
    nextPiece = getRandomShape();
    if (checkCollision(currentPiece)) { // Game Over
        gameRunning = false;
        alert('Game Over! Score: ' + score);
    }
}

function clearLines() {
    let linesCleared = 0;
    for (let r = ROWS - 1; r >= 0; r--) {
        if (grid[r].every(cell => cell !== 0)) {
            grid.splice(r, 1); // Удаляем заполненную линию
            grid.unshift(new Array(COLUMNS).fill(0)); // Добавляем пустую линию вверху
            linesCleared++;
        }
    }

    if (linesCleared > 0) {
        score += calculateScore(linesCleared);
        scoreDisplay.textContent = 'Score: ' + score;
    }
}


function calculateScore(linesCleared) {
    switch (linesCleared) {
        case 1:
            return 100;
        case 2:
            return 300;
        case 3:
            return 500;
        case 4:
            return 800;
        default:
            return 0;
    }
}

function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;

    if (!gameRunning) {
        return;
    }

    dropInterval = Math.max(200, 1000 - score * 2); // Увеличиваем скорость со счётом

    if (deltaTime > dropInterval) {
        if (!checkCollision(currentPiece, 0, 1)) {
            currentPiece.y++; // Двигаем вниз
        } else {
            placePiece();
        }
    }
    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Очистка канваса
    drawGrid();
    drawPiece(currentPiece, ctx, BLOCK_SIZE);
    drawNextPiece();
}


// Управление
document.addEventListener('keydown', event => {
    if (!gameRunning) return;

    switch (event.key) {
        case 'ArrowLeft':
            if (!checkCollision(currentPiece, -1, 0)) {
                currentPiece.x--;
            }
            break;
        case 'ArrowRight':
            if (!checkCollision(currentPiece, 1, 0)) {
                currentPiece.x++;
            }
            break;
        case 'ArrowDown':  // Мягкий дроп
            if (!checkCollision(currentPiece, 0, 1)) {
                currentPiece.y++;
            }
            break;
        case 'ArrowUp': // Поворот
            let rotated = (currentPiece.rotation + 1) % 4
            if (!checkCollision(currentPiece, 0, 0, 1)) {
                currentPiece.rotation = rotated
             }
            break;
    }
});

// Start the game
requestAnimationFrame(update);
</script>

</body>
</html>