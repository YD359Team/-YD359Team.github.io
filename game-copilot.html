<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Тетрис — одна страница</title>
  <style>
    :root {
      --cell: 30px;           /* размер клетки */
      --gap: 1px;             /* зазор между клетками */
      --bg: #0d0f12;          /* фон доски */
      --grid: #1a1f26;        /* цвет сетки */
      --text: #e6edf3;        /* текст */
      --accent: #6ea8fe;      /* акцент */
      --over: rgba(0,0,0,0.7);/* оверлей Game Over */
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: #0b0e12 linear-gradient(180deg, #0b0e12, #0a0c10);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      display: grid;
      place-items: center;
    }
    .wrap {
      display: grid;
      grid-template-columns: auto;
      gap: 12px;
      align-items: start;
      justify-items: center;
      padding: 12px;
    }
    .hud {
      width: calc(var(--cell) * 10 + var(--gap) * 9 + 12px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 8px 10px;
      background: #0f141b;
      border: 1px solid #1f2630;
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    }
    .title {
      font-weight: 700;
      letter-spacing: 0.5px;
      color: var(--accent);
    }
    .score {
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }
    .board {
      position: relative;
      width: calc(var(--cell) * 10 + var(--gap) * 9);
      height: calc(var(--cell) * 20 + var(--gap) * 19);
      display: grid;
      grid-template-columns: repeat(10, var(--cell));
      grid-template-rows: repeat(20, var(--cell));
      gap: var(--gap);
      background: var(--bg);
      border: 1px solid #1f2630;
      border-radius: 8px;
      padding: 6px;
      box-shadow: 0 12px 36px rgba(0,0,0,0.45), inset 0 0 0 1px rgba(255,255,255,0.02);
    }
    .cell {
      width: var(--cell);
      height: var(--cell);
      background: var(--grid);
      border-radius: 4px;
      transition: background-color 90ms linear, transform 90ms linear;
    }
    /* Цвета фигур */
    .I { background: #00c3ff; box-shadow: inset 0 -3px 0 rgba(0,0,0,0.25); }
    .O { background: #ffd500; box-shadow: inset 0 -3px 0 rgba(0,0,0,0.25); }
    .T { background: #9d4edd; box-shadow: inset 0 -3px 0 rgba(0,0,0,0.25); }
    .S { background: #22c55e; box-shadow: inset 0 -3px 0 rgba(0,0,0,0.25); }
    .Z { background: #ef4444; box-shadow: inset 0 -3px 0 rgba(0,0,0,0.25); }
    .J { background: #3b82f6; box-shadow: inset 0 -3px 0 rgba(0,0,0,0.25); }
    .L { background: #f59e0b; box-shadow: inset 0 -3px 0 rgba(0,0,0,0.25); }
    .ghost { background: #3a4554 !important; opacity: 0.35; }

    .overlay {
      pointer-events: none;
      position: absolute;
      inset: 6px;
      display: grid;
      place-items: center;
    }
    .overlay.hidden { display: none; }
    .panel {
      pointer-events: auto;
      padding: 16px 18px;
      background: var(--over);
      border: 1px solid #2a3543;
      border-radius: 10px;
      text-align: center;
      backdrop-filter: blur(2px);
    }
    .panel h2 {
      margin: 0 0 8px 0;
      font-size: 20px;
    }
    .panel p {
      margin: 4px 0 0 0;
      font-size: 14px;
      opacity: 0.9;
    }
    .kbd {
      display: inline-block;
      padding: 1px 6px;
      border: 1px solid #3a4656;
      border-bottom-width: 2px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #111620;
      color: #cbd5e1;
    }

    /* Небольшая адаптация для узких экранов */
    @media (max-width: 420px) {
      :root { --cell: 22px; }
      .hud { width: calc(var(--cell) * 10 + var(--gap) * 9 + 12px); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="title">Тетрис</div>
      <div class="score">Счёт: <span id="score">0</span></div>
    </div>

    <div class="board" id="board" tabindex="0" aria-label="Игровое поле">
      <!-- 200 клеток будут добавлены скриптом -->
      <div class="overlay hidden" id="overlay">
        <div class="panel">
          <h2 id="status">Игра окончена</h2>
          <p><span class="kbd">Enter</span> — начать заново</p>
          <p><span class="kbd">↑</span> поворот • <span class="kbd">↓</span> ускорение • <span class="kbd">←/→</span> движение</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const COLS = 10;
      const ROWS = 20;

      // Скорость и тайминги
      const BASE_DROP_MS = 800;    // один уровень скорости
      const SOFT_DROP_MS = 50;     // при зажатой стрелке вниз
      const LOCK_DELAY_MS = 500;   // небольшая задержка фиксации

      // Очки за линии по классике (без уровней)
      const SCORE_LINES = [0, 100, 300, 500, 800];

      // 7-бэг генератор фигур для честного рандома
      const TYPES = ["I", "O", "T", "S", "Z", "J", "L"];

      // Матрицы 4х4 для каждой фигуры и поворота (0..3)
      const SHAPES = {
        I: [
          [
            [0,0,0,0],
            [1,1,1,1],
            [0,0,0,0],
            [0,0,0,0],
          ],
          [
            [0,0,1,0],
            [0,0,1,0],
            [0,0,1,0],
            [0,0,1,0],
          ],
          [
            [0,0,0,0],
            [0,0,0,0],
            [1,1,1,1],
            [0,0,0,0],
          ],
          [
            [0,1,0,0],
            [0,1,0,0],
            [0,1,0,0],
            [0,1,0,0],
          ],
        ],
        O: [
          [
            [0,1,1,0],
            [0,1,1,0],
            [0,0,0,0],
            [0,0,0,0],
          ],
          // У O повороты эквивалентны
          [
            [0,1,1,0],
            [0,1,1,0],
            [0,0,0,0],
            [0,0,0,0],
          ],
          [
            [0,1,1,0],
            [0,1,1,0],
            [0,0,0,0],
            [0,0,0,0],
          ],
          [
            [0,1,1,0],
            [0,1,1,0],
            [0,0,0,0],
            [0,0,0,0],
          ],
        ],
        T: [
          [
            [0,1,0,0],
            [1,1,1,0],
            [0,0,0,0],
            [0,0,0,0],
          ],
          [
            [0,1,0,0],
            [0,1,1,0],
            [0,1,0,0],
            [0,0,0,0],
          ],
          [
            [0,0,0,0],
            [1,1,1,0],
            [0,1,0,0],
            [0,0,0,0],
          ],
          [
            [0,1,0,0],
            [1,1,0,0],
            [0,1,0,0],
            [0,0,0,0],
          ],
        ],
        S: [
          [
            [0,1,1,0],
            [1,1,0,0],
            [0,0,0,0],
            [0,0,0,0],
          ],
          [
            [0,1,0,0],
            [0,1,1,0],
            [0,0,1,0],
            [0,0,0,0],
          ],
          [
            [0,0,0,0],
            [0,1,1,0],
            [1,1,0,0],
            [0,0,0,0],
          ],
          [
            [1,0,0,0],
            [1,1,0,0],
            [0,1,0,0],
            [0,0,0,0],
          ],
        ],
        Z: [
          [
            [1,1,0,0],
            [0,1,1,0],
            [0,0,0,0],
            [0,0,0,0],
          ],
          [
            [0,0,1,0],
            [0,1,1,0],
            [0,1,0,0],
            [0,0,0,0],
          ],
          [
            [0,0,0,0],
            [1,1,0,0],
            [0,1,1,0],
            [0,0,0,0],
          ],
          [
            [0,1,0,0],
            [1,1,0,0],
            [1,0,0,0],
            [0,0,0,0],
          ],
        ],
        J: [
          [
            [1,0,0,0],
            [1,1,1,0],
            [0,0,0,0],
            [0,0,0,0],
          ],
          [
            [0,1,1,0],
            [0,1,0,0],
            [0,1,0,0],
            [0,0,0,0],
          ],
          [
            [0,0,0,0],
            [1,1,1,0],
            [0,0,1,0],
            [0,0,0,0],
          ],
          [
            [0,1,0,0],
            [0,1,0,0],
            [1,1,0,0],
            [0,0,0,0],
          ],
        ],
        L: [
          [
            [0,0,1,0],
            [1,1,1,0],
            [0,0,0,0],
            [0,0,0,0],
          ],
          [
            [0,1,0,0],
            [0,1,0,0],
            [0,1,1,0],
            [0,0,0,0],
          ],
          [
            [0,0,0,0],
            [1,1,1,0],
            [1,0,0,0],
            [0,0,0,0],
          ],
          [
            [1,1,0,0],
            [0,1,0,0],
            [0,1,0,0],
            [0,0,0,0],
          ],
        ],
      };

      // Простые wall-kick смещения (неполное SRS, но близко к ожидаемому поведению)
      const KICKS = [
        [0, 0], [1, 0], [-1, 0], [2, 0], [-2, 0], [0, -1], [1, -1], [-1, -1]
      ];

      // DOM
      const boardEl = document.getElementById('board');
      const scoreEl = document.getElementById('score');
      const overlayEl = document.getElementById('overlay');
      const statusEl = document.getElementById('status');

      // Инициализация сетки
      const cells = [];
      function buildGrid() {
        boardEl.querySelectorAll('.cell').forEach(n => n.remove());
        for (let i = 0; i < ROWS * COLS; i++) {
          const c = document.createElement('div');
          c.className = 'cell';
          boardEl.appendChild(c);
          cells.push(c);
        }
      }

      function idx(x, y) { return y * COLS + x; }

      function emptyRow() { return Array(COLS).fill(0); }
      function createBoard() { return Array.from({ length: ROWS }, emptyRow); }

      let board = createBoard();

      // Текущее состояние
      let bag = [];
      let piece = null;        // {type, rot, x, y}
      let score = 0;
      let running = false;
      let gameOver = false;

      let dropMs = BASE_DROP_MS;
      let dropAcc = 0;
      let lastTs = 0;

      let softDrop = false;
      let lockUntil = null;  // timestamp когда нужно зафиксировать текущую фигуру

      // Генерация следующей фигуры (7-бэг)
      function refillBag() {
        bag = TYPES.slice();
        for (let i = bag.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [bag[i], bag[j]] = [bag[j], bag[i]];
        }
      }
      function nextType() {
        if (bag.length === 0) refillBag();
        return bag.pop();
      }

      function spawn() {
        const type = nextType();
        piece = {
          type,
          rot: 0,
          x: 3,  // стартовая колонка (для 4х4 удобно 3)
          y: -2  // чуть выше поля, чтобы было место для длинных фигур
        };
        if (!valid(piece, piece.x, piece.y, piece.rot)) {
          // Нельзя заспавнить — игра окончена
          running = false;
          gameOver = true;
          showOverlay('Игра окончена');
        }
      }

      // Проверка валидности позиции
      function valid(p, nx, ny, nrot) {
        const m = SHAPES[p.type][nrot];
        for (let r = 0; r < 4; r++) {
          for (let c = 0; c < 4; c++) {
            if (!m[r][c]) continue;
            const x = nx + c;
            const y = ny + r;
            if (x < 0 || x >= COLS || y >= ROWS) return false;
            if (y >= 0 && board[y][x]) return false;
          }
        }
        return true;
      }

      // Фиксация фигуры в поле
      function merge() {
        const m = SHAPES[piece.type][piece.rot];
        for (let r = 0; r < 4; r++) {
          for (let c = 0; c < 4; c++) {
            if (!m[r][c]) continue;
            const x = piece.x + c;
            const y = piece.y + r;
            if (y >= 0) board[y][x] = piece.type;
          }
        }
        clearLines();
        piece = null;
        lockUntil = null;
        spawn();
      }

      // Очистка заполненных линий
      function clearLines() {
        let cleared = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
          if (board[y].every(v => v)) {
            board.splice(y, 1);
            board.unshift(emptyRow());
            cleared++;
            y++; // перепроверить текущий индекс после сдвига
          }
        }
        if (cleared > 0) {
          score += SCORE_LINES[cleared];
          updateScore();
        }
      }

      function updateScore() {
        scoreEl.textContent = String(score);
      }

      // Рисование
      function draw() {
        // очистка
        for (let i = 0; i < cells.length; i++) {
          const cell = cells[i];
          cell.className = 'cell';
        }
        // поле
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const t = board[y][x];
            if (t) {
              cells[idx(x, y)].classList.add(t);
            }
          }
        }
        // тень (ghost)
        if (piece) {
          const gy = ghostY();
          paintShape(piece.x, gy, piece.rot, 'ghost');
          // текущая фигура
          paintShape(piece.x, piece.y, piece.rot, piece.type);
        }
      }

      function paintShape(px, py, rot, className) {
        const m = SHAPES[piece.type][rot];
        for (let r = 0; r < 4; r++) {
          for (let c = 0; c < 4; c++) {
            if (!m[r][c]) continue;
            const x = px + c;
            const y = py + r;
            if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
              cells[idx(x, y)].classList.add(className);
            }
          }
        }
      }

      function ghostY() {
        let gy = piece.y;
        while (valid(piece, piece.x, gy + 1, piece.rot)) gy++;
        return gy;
      }

      // Логика движения
      function move(dx) {
        if (!piece) return;
        const nx = piece.x + dx;
        if (valid(piece, nx, piece.y, piece.rot)) {
          piece.x = nx;
          if (!valid(piece, piece.x, piece.y + 1, piece.rot)) {
            // у кучи — начать/продлить lock delay
            ensureLockDelay();
          } else {
            lockUntil = null; // снова есть пространство — сбросить
          }
        }
      }

      function rotate(dir = 1) {
        if (!piece) return;
        const nrot = (piece.rot + (dir > 0 ? 1 : 3)) % 4;
        // пробуем с простыми сдвигами (киками)
        for (const [kx, ky] of KICKS) {
          const nx = piece.x + kx;
          const ny = piece.y + ky;
          if (valid(piece, nx, ny, nrot)) {
            piece.rot = nrot;
            piece.x = nx;
            piece.y = ny;
            if (!valid(piece, piece.x, piece.y + 1, piece.rot)) {
              ensureLockDelay();
            } else {
              lockUntil = null;
            }
            return;
          }
        }
        // если все варианты не подошли — оставить как есть
      }

      function softStep() {
        if (!piece) return;
        if (valid(piece, piece.x, piece.y + 1, piece.rot)) {
          piece.y += 1;
          if (softDrop) {
            score += 1; // очки за мягкий дроп
            updateScore();
          }
        } else {
          ensureLockDelay();
        }
      }

      function ensureLockDelay() {
        const now = performance.now();
        if (lockUntil == null) {
          lockUntil = now + LOCK_DELAY_MS;
        }
      }

      function hardLockIfDue(now) {
        if (!piece) return;
        if (!valid(piece, piece.x, piece.y + 1, piece.rot) && lockUntil != null && now >= lockUntil) {
          merge();
        }
      }

      // Цикл игры
      function loop(ts) {
        if (!running) {
          draw();
          return;
        }
        if (!lastTs) lastTs = ts;
        const dt = ts - lastTs;
        lastTs = ts;

        dropAcc += dt;
        const stepMs = softDrop ? SOFT_DROP_MS : BASE_DROP_MS;

        while (dropAcc >= stepMs) {
          dropAcc -= stepMs;
          softStep();
        }
        hardLockIfDue(ts);
        draw();
        requestAnimationFrame(loop);
      }

      // Управление
      const keysDown = new Set();
      window.addEventListener('keydown', (e) => {
        if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Enter"].includes(e.key)) e.preventDefault();

        if (gameOver && e.key === 'Enter') {
          restart();
          return;
        }
        if (!running && !gameOver && e.key === 'Enter') {
          start();
          return;
        }

        if (!running) return;

        if (e.key === 'ArrowLeft' && !keysDown.has('ArrowLeft')) move(-1);
        if (e.key === 'ArrowRight' && !keysDown.has('ArrowRight')) move(1);
        if (e.key === 'ArrowUp' && !keysDown.has('ArrowUp')) rotate(1);
        if (e.key === 'ArrowDown') softDrop = true;

        keysDown.add(e.key);
      });

      window.addEventListener('keyup', (e) => {
        keysDown.delete(e.key);
        if (e.key === 'ArrowDown') softDrop = false;
      });

      function showOverlay(text) {
        statusEl.textContent = text;
        overlayEl.classList.remove('hidden');
      }
      function hideOverlay() {
        overlayEl.classList.add('hidden');
      }

      function start() {
        if (running) return;
        if (!piece) spawn();
        running = true;
        gameOver = false;
        hideOverlay();
        lastTs = 0;
        dropAcc = 0;
        requestAnimationFrame(loop);
      }

      function restart() {
        board = createBoard();
        score = 0;
        updateScore();
        bag = [];
        piece = null;
        lockUntil = null;
        gameOver = false;
        running = true;
        hideOverlay();
        spawn();
        lastTs = 0;
        dropAcc = 0;
        requestAnimationFrame(loop);
      }

      // Стартовая инициализация
      buildGrid();
      draw();
      showOverlay('Нажмите Enter, чтобы играть');
      boardEl.focus();
    })();
  </script>
</body>
</html>